@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using de.springwald.xml.blazor.NativePlatform
@using de.springwald.xml.editor
@using Microsoft.JSInterop
@using de.springwald.xml.blazor.Code
@using CurrieTechnologies.Razor.Clipboard
@inject IJSRuntime JSRuntime
@inject ClipboardService clipboardService
@implements IDisposable

@if (this.showContextMenu)
{
    <div>Right click menu</div>
}

<div style="overflow: auto; @this.Style" @ref="_canvasDivReference">
    <div tabindex="0" class="canvasOuter" style="width:@(canvasWidth)px; min-width:@(canvasWidth)px; height: @(canvasHeight)px; max-height:@(canvasHeight)px"
         @onmousedown="EventOnMouseDown" @onmousemove="EventOnMouseMove" @onmouseup="EventOnMouseUp"
         @oncontextmenu="HandleRightClick" @oncontextmenu:preventDefault="true"
         @onkeydown="EventOnKeyDown" @onkeydown:preventDefault
         @onfocusout="EventFocusOut"
         @onfocus="EventFocusIn"
         @onfocusin="EventFocusIn">
        <BECanvas Width="@canvasWidth" Height="@canvasHeight" @ref="_canvasReference">
        </BECanvas>
    </div>
</div>

@code {

    private bool showContextMenu;

    protected BECanvasComponent _canvasReference;
    protected ElementReference _canvasDivReference;

    protected int outerWidth = 10;
    protected int canvasWidth = 10;
    protected int canvasHeight = 10;

    public de.springwald.xml.editor.XmlEditor Editor;

    [Parameter]
    public EditorContext EditorContext { get; set; }

    [Parameter]
    public string Style { get; set; }

    [Parameter] public EventCallback OnReady { get; set; }

    protected override Task OnInitializedAsync()
    {
        return base.OnInitializedAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await this.Init();
            await JSRuntime.InvokeVoidAsync("browserResize.registerResizeCallback");
            BrowserResize.OnResize += this.OuterResized;
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    private async Task Init()
    {
        if (this.EditorContext == null) throw new ArgumentNullException(nameof(this.EditorContext));
        this.EditorContext.NativePlatform = new BlazorNativePlatform(_canvasReference, new BlazorClipboard(this.clipboardService));
        this.Editor = new editor.XmlEditor(this.EditorContext);
        this.EditorContext.EditorState.RootNodeChanged.Add(this.RootNodeChanged);
        this.Editor.VirtualSizeChanged.Add(this.VirtualSizeChanged);
        await OnReady.InvokeAsync(EventArgs.Empty);
    }

    public void Dispose()
    {
        BrowserResize.OnResize -= this.OuterResized;
        this.EditorContext?.EditorState.RootNodeChanged.Remove(this.RootNodeChanged);
        this.Editor.VirtualSizeChanged.Remove(this.VirtualSizeChanged);
        this.Editor.Dispose();
    }

    private async Task RootNodeChanged(System.Xml.XmlNode rootNode)
    {
        await this.Editor.SetRootNode(rootNode);
        await this.OuterResized();
        StateHasChanged();
    }

    private async Task VirtualSizeChanged(EventArgs e)
    {
        var changed = false;
        const int tolerance = 30;
        if (Math.Abs((this.Editor.VirtualHeight + tolerance) - this.canvasHeight) > tolerance)
        {
            changed = true;
            this.canvasHeight = this.Editor.VirtualHeight + tolerance;
        }

        if (this.outerWidth > this.canvasWidth)
        {
            this.canvasWidth = this.outerWidth;
            changed = true;
        }
        else
        {
            var targetWidth = Math.Max(this.outerWidth, this.Editor.VirtualWidth + tolerance);
            if (Math.Abs(targetWidth - this.canvasWidth) > tolerance)
            {
                this.canvasWidth = targetWidth;
                changed = true;
            }
        }

        if (changed)
        {
            await this.EditorContext.NativePlatform.SetSize(this.canvasWidth, this.canvasHeight);
            this.StateHasChanged();
            this.Editor.SizeHasChanged();
        }
    }

    public class BoundingClientRect
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
        public double Top { get; set; }
        public double Right { get; set; }
        public double Bottom { get; set; }
        public double Left { get; set; }
    }

    private async Task OuterResized()
    {
        var size = await JSRuntime.InvokeAsync<BoundingClientRect>
    ("MyDOMGetBoundingClientRect", new object[] { this._canvasDivReference });
        if (size == null) return;
        this.outerWidth = (int)size.Width - 40;
        await this.VirtualSizeChanged(EventArgs.Empty);
    }

    #region key events

    public async void EventFocusIn(FocusEventArgs e)
    {
        this.EditorContext.EditorState.HasFocus = true;
        // this.EditorContext.NativePlatform.InputEvents.FocusIn.Trigger(EventArgs.Empty);
    }

    public async void EventFocusOut(FocusEventArgs e)
    {
        this.EditorContext.EditorState.HasFocus = false;
        // this.EditorContext.NativePlatform.InputEvents.FocusIn.Trigger(EventArgs.Empty);
    }

    public async void EventOnKeyDown(KeyboardEventArgs e)
    {
        var args = new de.springwald.xml.events.KeyEventArgs
        {
            CtrlKey = e.CtrlKey,
            AltKey = e.AltKey,
            ShiftKey = e.ShiftKey,
            Content = e.Key,
            Key = events.Keys.undefined
        };

        switch (e.Key)
        {
            // check control keys here to prevent checking ControlLeft vs. ControlRight etc.

            case "Control":
            case "Shift":
            case "Alt":
                // skip this keydowns
                return;

            case "Home": args.Key = events.Keys.Home; break;
            case "Enter": args.Key = events.Keys.Enter; break;

            default:

                // check other keys in detail by key code

                switch (e.Code)
                {
                    case "KeyA": args.Key = events.Keys.A; break;
                    case "KeyC": args.Key = events.Keys.C; break;
                    case "KeyS": args.Key = events.Keys.S; break;
                    case "KeyV": args.Key = events.Keys.V; break;
                    case "KeyX": args.Key = events.Keys.X; break;
                    case "KeyY": args.Key = events.Keys.Y; break;
                    case "KeyZ": args.Key = events.Keys.Z; break;

                    case "Backspace": args.Key = events.Keys.Back; break;
                    case "Delete": args.Key = events.Keys.Delete; break;
                    case "Escape": args.Key = events.Keys.Escape; break;

                    case "ArrowLeft": args.Key = events.Keys.Left; break;
                    case "ArrowRight": args.Key = events.Keys.Right; break;

                    case "Tab":
                        args.Key = events.Keys.Tab;
                        break;
                }
                break;
        }

        await this.EditorContext.NativePlatform.InputEvents.PreviewKey.Trigger(args);
    }

    #endregion

    #region mouse events

    async void EventOnMouseDown(MouseEventArgs e)
    {
        var result = await JSRuntime.InvokeAsync<BoundingClientRect>
            ("MyDOMGetBoundingClientRect", new object[] { this._canvasDivReference });

        var x = (int)(e.ClientX - result.Left);
        var y = (int)(e.ClientY - result.Top);

        await this.EditorContext.NativePlatform.InputEvents.MouseDown.Trigger(new de.springwald.xml.events.MouseEventArgs
        {
            X = x,
            Y = y
        });
    }

    async void EventOnMouseMove(MouseEventArgs e)
    {
        var result = await JSRuntime.InvokeAsync<BoundingClientRect>
            ("MyDOMGetBoundingClientRect", new object[] { this._canvasDivReference });

        var x = (int)(e.ClientX - result.Left);
        var y = (int)(e.ClientY - result.Top);

        await this.EditorContext.NativePlatform.InputEvents.MouseMove.Trigger(new de.springwald.xml.events.MouseEventArgs
        {
            X = x,
            Y = y
        });
    }

    async void EventOnMouseUp(MouseEventArgs e)
    {
        var result = await JSRuntime.InvokeAsync<BoundingClientRect>
            ("MyDOMGetBoundingClientRect", new object[] { this._canvasDivReference });

        var x = (int)(e.ClientX - result.Left);
        var y = (int)(e.ClientY - result.Top);

        await this.EditorContext.NativePlatform.InputEvents.MouseUp.Trigger(new de.springwald.xml.events.MouseEventArgs
        {
            X = x,
            Y = y
        });
    }

    void HandleRightClick(MouseEventArgs args)
    {
        if (args.Button == 2) this.showContextMenu = true;
    }

    #endregion

                }
