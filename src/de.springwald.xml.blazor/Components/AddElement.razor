@using de.springwald.xml.editor
@using de.springwald.xml.dtd
@implements IDisposable


@foreach (var group in groups)
{
    var elems = this.elements.Where(e => e.Group == group);
    if (elems.Any())
    {
        <div style="border-width:1px; border-color: gray; border-style: solid;">
            @if (group != null)
            {
                <p>@group.Titel</p>
            }
            <ul>
                @foreach (var element in elems)
                {
                    <li @onclick="(async () => await this.ClickElement(element.Title))">@element.Title</li>
                }
            </ul>
        </div>
    }
}

@code {

    private class Element
    {
        public string Title { get; set; }
        public XMLElementGruppe Group { get; set; }
    }

    [Parameter]
    public EditorContext EditorContext { get; set; }
    private EditorStatus EditorStatus => this.EditorContext.EditorStatus;

    private Element[] elements = new Element[] { };
    private XMLElementGruppe[] groups = new XMLElementGruppe[] { };

    protected override Task OnInitializedAsync()
    {
        this.EditorStatus.CursorRoh.ChangedEvent.Add(this.Show);
        return base.OnInitializedAsync();
    }

    public void Dispose()
    {
        this.EditorStatus.CursorRoh.ChangedEvent.Remove(this.Show);
    }

    protected async Task ClickElement(string element)
    {
        await this.EditorContext.Actions.AktionNeuesElementAnAktCursorPosEinfuegen(element, EditorActions.UndoSnapshotSetzenOptionen.ja, neueCursorPosAufJedenFallHinterDenEingefuegtenNodeSetzen: false);
        StateHasChanged();
    }


    public async Task Show(EventArgs eventArgs)
    {
        if ((this.EditorContext.EditorStatus.RootNode != null))  //  genug Daten, um einzufügenden Elemente aufzulisten
        {
            string[] elemente = null;

            try
            {
#if CommentNichtZulassen
            bool kommentareMitAuflisten = false;
#else
                bool kommentareMitAuflisten = true;
#endif
                var elementsRaw = this.EditorContext.XmlRules.ErlaubteEinfuegeElemente_(this.EditorStatus.CursorOptimiert.StartPos, false, kommentareMitAuflisten); // die Liste der erlaubten Tags holen
                this.groups = this.EditorContext.XmlRules.ElementGruppen.Append(null).ToArray();
                this.elements = elementsRaw.Select(e => new Element { Title = e, Group = groups.Where(g => g != null && g.ContainsElement(e)).FirstOrDefault() }).ToArray();
                this.StateHasChanged();
            }
            catch (DTD.XMLUnknownElementException e)
            {
                var error = $"unknown element '{e.ElementName}'";
                //Debugger.GlobalDebugger.Protokolliere(String.Format("unknown element {0} in {1}->{2}", e.ElementName, this.Name, "Aktualisieren"));  //Eines der bezogenen Elemente ist in der DTD unbekannt
                //lblFehler.Text = String.Format("unknown element '{0}'", e.ElementName);
                //lblFehler.Visible = true;
            }

            if (elemente != null)
            {

                //// Elemente alphabetisch sortieren
                //string[] restElemente = (from e in elemente
                //                         orderby e
                //                         select e).ToArray();

                //// ButtonArray füllen
                //int rand = 3; // Abstand zwischen Buttons
                //int top = 0; // Dort anfangen

                //// Buttons in den Gruppen anzeigen
                //for (int i = 0; i < _gruppenControls.Count; i++)
                //{
                //    // Jetzt dem Gruppencontrol die Elemente übergeben, welche überhaupt zur Verfügung stehen
                //    restElemente = _gruppenControls[i].VerfuegbareElementeZuweisenUndRestElementeZurueckGeben(restElemente);

                //    if (_gruppenControls[i].Visible) // Ist das Gruppencontrol sichtbar?
                //    {
                //        _gruppenControls[i].Top = top;
                //        _gruppenControls[i].Left = rand;
                //        int breite = ClientSize.Width - rand * 2;
                //        _gruppenControls[i].Width = breite;
                //        top += _gruppenControls[i].Height;
                //    }
                //    else // Das Gruppencontrol ist nicht sichtbar - wohl weil es keine Buttons drin hat
                //    {
                //    }
                //}
            }
            await Task.CompletedTask;
        }
    }


}
